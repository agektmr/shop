<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-meta/iron-meta.html">
<script src="base64url-arraybuffer.js"></script>

<dom-module id="shop-account-data">

  <script>
    const SIGNUP = '/auth/register';
    const SIGNOUT = '/auth/signout';
    const UNREGISTER = '/auth/unregister';
    const SESSION = '/auth/session';
    const PASSWORD = '/auth/password';
    const PCHANGE = '/auth/change-password';
    const GOOGLE = '/auth/google';
    const GOOGLE_FEDERATION = 'https://accounts.google.com'
    const WEBAUTHN_MAKECRED = '/webauthn/makeCred';
    const WEBAUTHN_REGCRED = '/webauthn/regCred';
    const WEBAUTHN_GETASST = '/webauthn/getAsst';
    const WEBAUTHN_AUTHASST = '/webauthn/authAsst';
    const WEBAUTHN_REMOVE = '/webauthn/remove';
    const WEBAUTHN_KEYS = '/webauthn/keys';
    const REAUTH_DURATION = 1000 * 60 * 5; // 5 minutes

    class ShopAccountData extends Polymer.Element {

      static get is() {
        return 'shop-account-data';
      }

      static get properties() {
        return {
          profile: {
            type: Object,
            value: null,
            notify: true
          },

          keys: {
            type: Array,
            value: []
          },

          isUVPAA: {
            type: Boolean,
            value: false
          }
        }
      }

      ready() {
        super.ready();
        new Polymer.IronMeta({
          type: 'account',
          key: 'account',
          value: this
        });
        if (PublicKeyCredential &&
            PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable) {
          PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()
          .then(result => {
            this.isUVPAA = result;
            this.dispatchEvent(new CustomEvent('account-data-ready', {
              bubbles: true, composed: true
            }));
          });
        } else {
          return this.isUVPAA = false;
          this.dispatchEvent(new CustomEvent('account-data-ready', {
            bubbles: true, composed: true
          }));
        }
      }

      isSignedIn() {
        return !!(this.profile && this.profile.id);
      }

      setProfile(profile) {
        // Set profile
        this.profile = {
          name: profile.name,
          id: profile.id,
          iconURL: profile.imageUrl,
          email: profile.email,
          reauth: profile.reauth || 0
        };
      }

      checkSession(authLevel = 0) {
        return this._fetch(SESSION).then(profile => {
          // If authLevel is 2 or above, examine sign-in status.
          if (authLevel >= 2 && profile) {
            const now = (new Date()).getTime();
            const acceptable = now - REAUTH_DURATION;
            // If last reauth time not acceptable, execute reauth
            if (!profile.reauth || profile.reauth < acceptable) {
              // If UVPA is available and reauth key is stored
              if (this.isUVPAA && this.reauthKeyAvailable()) {
                // Try reauth
                return this.reauth();
              }
            }
          }
          return profile;
        }).then(profile => {
          if (authLevel >= 1 && !profile) {
            throw 'No profile';
          }
          if (profile) {
            this.setProfile(profile);
          } else {
            this._initializeProfile();
          }
          return profile;
        });
      }

      _initializeProfile() {
        // Init profile
        this.setProfile({
          name: '',
          id: '',
          iconURL: '',
          email: ''
        });
      }

      /**
       * Checks CM API availability, obtains a credential, then attempt to
       * sign-in, then finally sets profile info to this pobject.
       * @param {boolean} unmediated
       * @returns Promise<profile>
       **/
      async autoSignIn(unmediated) {
        // Do nothing when Credential API is not available
        if (!window.PasswordCredential) {
          return Promise.resolve();
        }

        try {
          // Attempt to get credentials and auto-login if possible
          const cred = await navigator.credentials.get({
            password: true,
            federated: {
              providers: [GOOGLE_FEDERATION]
            },
            mediation: unmediated ? 'silent' : 'optional'
          });

          // Ensure they're not empty
          if (!cred) {
            return Promise.resolve();
          }

          let profile;
          // TODO: Check creds with the auth backend
          if (cred.type === 'password') {
            let form = new FormData();
            form.append('email', cred.id);
            form.append('password', cred.password);
            profile = await this._fetch(PASSWORD, form)
          } else if (cred.type === 'federated') {
            // This credential must be GOOGLE
            profile = await this.gSignIn(cred.id);
          }

          if (profile) {
            this.setProfile(profile);
          }
          return Promise.resolve(profile);

        } catch (e) {
          console.error(e);
          this._initializeProfile();
          return Promise.reject(e);
        }
      }

      async pSignIn(form) {
        try {
          const profile = await this._fetch(PASSWORD, form);
          this.setProfile(profile);

          if (window.PasswordCredential) {
            let email = form.get('email');
            let password = form.get('password');
            let cred = new PasswordCredential({
              id: email,
              password: password
            });
            navigator.credentials.store(cred);
          }
          return Promise.resolve(profile);
        } catch (e) {
          return Promise.reject(e);
        }
      }

      async pReauth(form) {
        try {
          const url = `${PASSWORD}?reauth`;
          const profile = await this._fetch(url, form);
          this.setProfile(profile);

          if (window.PasswordCredential) {
            let email = form.get('email');
            let password = form.get('password');
            let cred = new PasswordCredential({
              id: email,
              password: password
            });
            navigator.credentials.store(cred);
          }
          return Promise.resolve(profile);
        } catch (e) {
          return Promise.reject(e);
        }
      }

      async pSignUp(form) {
        try {
          const profile = await this._fetch(SIGNUP, form)
          this.setProfile(profile);
          if (window.PasswordCredential) {
            let email = form.get('email');
            let password = form.get('password');
            let cred = new PasswordCredential({
              id: email,
              password: password
            });
            navigator.credentials.store(cred);
          }
          return Promise.resolve(profile);
        } catch (e) {
          return Promise.reject(e);
        }
      }

      async pChange(form) {
        const profile = await this._fetch(PCHANGE, form);
        if (window.PasswordCredential) {
          const cred = new PasswordCredential({
            id: profile.id,
            password: form.get('new-password1')
          });
          await navigator.credentials.store(cred);
        }
        return profile;
      }

      gSignIn(id) {
        return (function () {
          let auth2 = gapi.auth2.getAuthInstance();
          if (auth2.isSignedIn.get()) {
            let googleUser = auth2.currentUser.get();
            if (googleUser.getBasicProfile().getEmail() === id) {
              return Promise.resolve(googleUser);
            }
          }
          return auth2.signIn({
            login_hint: id || ''
          });
        })().then(googleUser => {
          let form = new FormData();
          form.append('id_token', googleUser.getAuthResponse().id_token);
          return this._fetch(GOOGLE, form);
        }).then(profile => {
          if (profile) {
            this.setProfile(profile);
            if (navigator.credentials) {
              // Signed in with Google Account
              let cred = new FederatedCredential({
                id: profile.email,
                name: profile.name,
                iconURL: profile.imageUrl,
                provider: GOOGLE_FEDERATION
              });
              navigator.credentials.store(cred);
            }
          }
          return Promise.resolve(profile);
        });
      }

      reauthKeyAvailable() {
        return !!localStorage.getItem('reauth');
      }

      _getReauthData() {
        return localStorage.getItem('reauth');
      }

      _setReauthData(credId) {
        localStorage.setItem('reauth', credId);
      }

      _removeReauthData() {
        const credId = localStorage.getItem('reauth');
        localStorage.removeItem('reauth');
        return credId;
      }

      async registerReauthKey() {
        if (!window.PublicKeyCredential) {
          throw 'WebAuthn not supported on this browser.';
        }
        // If reauth key is already registered, throw an exception
        if (this._getReauthData() !== null) {
          return Promise.reject('Reauth key alrady registered.');
        }

        const opts = {};
        if (!opts.authenticatorSelection) opts.authenticatorSelection = {};
        opts.authenticatorSelection.authenticatorAttachement = 'platform';
        opts.authenticatorSelection.userVerification = 'required';

        try {
          const options = await this._fetch(`${WEBAUTHN_MAKECRED}?reauth`, opts);
console.log('Response from makeCred', options);

          options.user.id = base64url.decode(options.user.id);
          options.challenge = base64url.decode(options.challenge);

          if (options.excludeCredentials) {
            for (let cred of options.excludeCredentials) {
              cred.id = base64url.decode(cred.id);
            }
          }

console.log('PublicKeyCredentialCreationOptions', options);

          const cred = await navigator.credentials.create({
            publicKey: options
          });
console.log('Response of `navigator.credentials.get()`', cred);

          const parsedCred = await this._encodeAuthenticatorAttestationResponse(cred);

          const profile = await this._fetch('webauthn/regCred?reauth', parsedCred);

          this._setReauthData(parsedCred.id);

          return Promise.resolve();
        } catch (e) {
          console.error(e);
          return Promise.reject(e);
        }
      }

      async removeReauthKey() {
        const credId = this._removeReauthData();
        const url = `${WEBAUTHN_REMOVE}?reauth=${encodeURIComponent(credId)}`;
        return await this._fetch(url);
      }

      async reauth() {
        if (!window.PublicKeyCredential) {
          throw 'WebAuthn not supported on this browser.';
        }

        const credId = this._getReauthData();
        try {
          const url =`${WEBAUTHN_GETASST}?reauth=${encodeURIComponent(credId)}`;
          const options = await this._fetch(url);

  console.log('Response from getAsst', options);

          options.challenge = base64url.decode(options.challenge);

          if (options.allowCredentials) {
            for (let cred of options.allowCredentials) {
              cred.id = base64url.decode(cred.id);
            }
          }

          const cred = await navigator.credentials.get({
            publicKey: options
          });

          const parsedCred = await this._encodeAuthenticatorAssertionResponse(cred);

          return await this._fetch(`${WEBAUTHN_AUTHASST}?reauth`, parsedCred);
        } catch (e) {
          console.error(e);
          throw 'Reauth failed!';
        }
      }

      async getKeys() {
        if (!window.PublicKeyCredential) {
          throw 'WebAuthn not supported on this browser.';
        }
        try {
          return await this._fetch(WEBAUTHN_KEYS);
        } catch (e) {
          return Promise.reject(e);
        }
      }

      async _encodeAuthenticatorAttestationResponse(atts) {
        const credential = {};
        if (atts.id)    credential.id =     atts.id;
        if (atts.type)  credential.type =   atts.type;
        if (atts.rawId) credential.rawId =  base64url.encode(atts.rawId);

        if (atts.response) {
          const clientDataJSON =
            base64url.encode(atts.response.clientDataJSON);
          const attestationObject =
            base64url.encode(atts.response.attestationObject);
          const signature =
            base64url.encode(atts.response.signature);
          const userHandle =
            base64url.encode(atts.response.userHandle);
          credential.response = {
            clientDataJSON,
            attestationObject,
            signature,
            userHandle
          };
        }
        return credential;
      }

      async _encodeAuthenticatorAssertionResponse(asst) {
        const credential = {};
        if (asst.id)    credential.id =     asst.id;
        if (asst.type)  credential.type =   asst.type;
        if (asst.rawId) credential.rawId =  base64url.encode(asst.rawId);

        if (asst.response) {
          const clientDataJSON =
            base64url.encode(asst.response.clientDataJSON);
          const authenticatorData =
            base64url.encode(asst.response.authenticatorData);
          const signature =
            base64url.encode(asst.response.signature);
          const userHandle =
            base64url.encode(asst.response.userHandle);
          credential.response = {
            clientDataJSON,
            authenticatorData,
            signature,
            userHandle
          };
        }
        return credential;
      }

      async registerCredential(opts) {
        if (!window.PublicKeyCredential) {
          throw 'WebAuthn not supported on this browser.';
        }
        try {
          const options = await this._fetch(`${WEBAUTHN_MAKECRED}`, opts);

console.log('Response from makeCred', options);

          options.user.id = base64url.decode(options.user.id);
          options.challenge = base64url.decode(options.challenge);

          if (options.excludeCredentials) {
            for (let cred of options.excludeCredentials) {
              cred.id = base64url.decode(cred.id);
            }
          }

console.log('PublicKeyCredentialCreationOptions', options);

          const cred = await navigator.credentials.create({
            publicKey: options
          });

console.log('Response of `navigator.credentials.get()`', cred);

          const parsedCred = await this._encodeAuthenticatorAttestationResponse(cred);

          return await this._fetch(`${WEBAUTHN_REGCRED}`, parsedCred);

        } catch (e) {
          console.error(e);
          return Promise.reject(e);
        }
      }

      async assertCredential() {
        try {
          const options = await this._fetch(`${WEBAUTHN_GETASST}`);

console.log('Response from getAsst', options);

          options.challenge = base64url.decode(options.challenge);

          if (options.allowCredentials) {
            for (let cred of options.allowCredentials) {
              cred.id = base64url.decode(cred.id);
            }
          }

          const asst = await navigator.credentials.get({
            publicKey: options
          });

          const credential = {};
          if (asst.id)    credential.id =     asst.id;
          if (asst.type)  credential.type =   asst.type;
          if (asst.rawId) credential.rawId =  base64url.encode(asst.rawId);

          if (asst.response) {
            const clientDataJSON =
              base64url.encode(asst.response.clientDataJSON);
            const authenticatorData =
              base64url.encode(asst.response.authenticatorData);
            const signature =
              base64url.encode(asst.response.signature);
            const userHandle =
              base64url.encode(asst.response.userHandle);
            credential.response = {
              clientDataJSON,
              authenticatorData,
              signature,
              userHandle
            };
          }

          const result = await this._fetch(`${WEBAUTHN_AUTHASST}`, credential);
        } catch (e) {
          return Promise.reject(e);
        }
      }

      async removeCredential(credId) {
        if (!window.PublicKeyCredential) {
          throw 'WebAuthn not supported on this browser.';
        }
        try {
          await this._fetch(WEBAUTHN_REMOVE, { credId })
          return;
        } catch (e) {
          return Promise.reject(e);
        }
      }

      async _fetch(path, cred = '') {
        const headers = {
          'X-Requested-With': 'XMLHttpRequest'
        };
        if (cred && !(cred instanceof FormData)) {
          headers['Content-Type'] = 'application/json';
          cred = JSON.stringify(cred);
        }
        try {
          const res = await fetch(path, {
            method: 'POST',
            credentials: 'include',
            headers: headers,
            body: cred
          });
          if (res.status === 200) {
            // Server authentication succeeded
            return res.json();
          } else {
            const text = await res.text();
            // Server authentication failed
            throw text;
          }
        } catch (e) {
          return Promise.reject(e);
        }
      }

      logout() {
        return this._fetch(SIGNOUT)
        .then(() => {
          if (PasswordCredential) {
            navigator.credentials.preventSilentAccess();
          }
          this._initializeProfile();
        });
      }

    };

    customElements.define(ShopAccountData.is, ShopAccountData);
  </script>

</dom-module>